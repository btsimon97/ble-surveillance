#! /usr/bin/python3

# A tool that uses the KismetExternal API and Kismet eventbus to forward
# events from Kismet to an external program using UNIX Sockets.
#
# Derived from the eventbus demo plugin that ships with Kismet
#
# Only forwards NEW_DEVICE events, but can be modified for other events too.
#
# This uses the python_tools/KismetExternal python module to integrate with 
# the eventbus and print events to the console.

import argparse
import os
import time
import sys
import threading
import json
import socket

# Pretty-print the failure
try:
    import kismetexternal
except ImportError:
    print("ERROR:  Kismet external Python tools require the kismetexternal python ")
    print("        library; you can find it in the kismetexternal git or via pip")
    sys.exit(1)

class KismetProxyTest(object):
    def __init__(self):
        # Try to parse the arguments to find the descriptors we need to give to 
        # the kismet external tool; Kismet calls external helpers with a pre-made
        # set of pipes on --in-fd and --out-fd
        self.parser = argparse.ArgumentParser(description='Kismet Event Forwarder -- Python')

        self.parser.add_argument('--in-fd', action="store", type=int, dest="infd")
        self.parser.add_argument('--out-fd', action="store", type=int, dest="outfd")

        self.results = self.parser.parse_args()

        if self.results.infd is None or self.results.outfd is None:
            print("ERROR:  Kismet external python tools are (typically) launched by ")
            print("        Kismet itself; running it on its own won't do what you want")
            sys.exit(1)

        print("Kismet Event Forwarder Plugin loaded KismetExternal API {}".format(kismetexternal.__version__))

        # Initialize our external interface
        self.kei = kismetexternal.ExternalInterface(self.results.infd, self.results.outfd)

        # Start the external handler BEFORE we register our handlers, since we need to be
        # connected to send them!
        self.kei.start()

        # Register an event handler for all events
        self.kei.add_event_handler("*", self.handle_event)  # Change this to NEW_DEVICE once subscription works

        # Start the IO loops running
        self.kei.run()

    def handle_event(self, event, dictionary):
        #print("Eventbus got {}".format(event))
        if event == "NEW_DEVICE":  # Work around Kismet sending every event by ignoring everything except NEW_DEVICE
            # Initialize UNIX Socket for transmission of data
            data_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            socket_path = '/run/bt-surveillance-processing.sock'
            try:
                data_socket.connect(socket_path)
            except socket.error as msg:
                print("Encountered an error while setting up the data socket for event forwarding.")
                print(msg)
                return  # The socket isn't setup for transmission, bailout of trying to send data.

            # Send the event data to the socket.
            try:
                data_socket.send(json.dumps(dictionary['NEW_PHY']).encode())
                print(json.dumps(dictionary['NEW_PHY']))
            finally:
                data_socket.close()

    # Loop forever
    def loop(self):
        while self.kei.is_running():
            self.kei.send_ping()
            time.sleep(1)

        self.kei.kill()


if __name__ == "__main__":
    # Make a proxytest and loop forever
    pt = KismetProxyTest()

    # Loop in a detached process
    pt.loop()
